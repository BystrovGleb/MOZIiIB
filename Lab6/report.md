---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Простейший вариант"
author: "<Быстров Глеб Андреевич>"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

- Получить понимание как раскладывать числа на множители.

# Задание

- Реализовать алгоритм p-метода Полларда
- Реализовать метод квадратов (Теорема Ферма о разложении)

# Теоретическое введение

Метод Полларда — один из методов факторизации целых чисел.

Впервые опубликован британским математиком Джоном Поллардом[англ.] в 1974 году. Именно появление данного алгоритма привело к изменению понятия сильного простого числа, используемого в криптографии, нестрого говоря, простого числа, для которого p−1 имеет достаточно большие делители. В современных криптосистемах стараются использовать именно сильные простые числа, так как это повышает стойкость используемых алгоритмов и систем в целом.

Пусть N - составное число, и В - заранее выбранная верхняя грань. Этот алгоритм будет пытаться найти нетривиальный делитель N, но это получится только если существует простой делитель N, такой что p-1 - гладкое степени B. Мы предполагаем, что уже есть таблица p[1], ..., p[k] всех простых до B.
[Инициализация]
     Пусть x := 2, y := x, P := 1, c := 0, i := 0, j := i.

[Следующее простое]
     Пусть i := i + 1. Если i > k, вычислим g = НОД ( P , N ). Если g = 1, выведем сообщение, что разложение не удалось и выйдем, иначе i := j, x := y и идти на шаг 5. Иначе ( т.е если i <= k ), q := p[i], q1 := q, L := [ B / q ].

[Вычисляем степень]
     Пока q1 <= L, пусть q1 := q * q1. Затем, пусть x := xq1 mod N, P := P * (x-1) mod N, c := c + 1, и , если c < 20, идти на шаг 2.

[Вычисляем НОД]
     Пусть g := НОД ( P , N ). Если g = 1, пусть c := 0, j := i, y := x и идти на шаг 2. Иначе пусть i := j, x := y.

[Обратный ход]
Пусть i := i + 1, q := p[i] и q1 := q.

Пусть x := xq mod N, g := НОД ( x - 1 , N ). Если g = 1, пусть q1 := q * q1 и если q <= B, идти на шаг 6, иначе - на шаг 5. Иначе (т.е если g >= 1), если g < N, вывести g и выйти. Если g = N (редкий случай), вывести, что разложение не удалось и выйти.

Заметим, что этот алгоритм может прекратить работу по двум различным причинам. Первая, самая часто встречающаяся, проявит себя в шаге 2. Это то, что N не имеет простых делителей p таких, что p-1 - гладкое степени B. При этом данный факт можно будет считать доказанным.

Вторая причина ( в шаге 6 ) чрезвычайно редка. Это будет означать, что все простые делители N найдены одновременно. Если это так, то, очевидно, существует p - делитель N, которое является гладким степени B. Значит, стоит попробовать запустить алгоритм с другим начальным значением x, например, x := 3 вместо x :=2.

Даже в такой простой форме поведение p-1 алгоритма довольно впечатляюще. Разумеется, он не претендует на получение полного разложения ( например, когда N = ( 2 * p + 1 ) * ( 2 * q + 1 ), где p, q, 2 * p + 1 и 2 * q + 1 простые, причем p и q примерно одного размера, время работы алгоритма будет O( N1/2+e ), если мы хотим разложить N полностью, не лучше простого деления ). С другой стороны, его можно удачно использовать для нахождения даже очень больших делителей N, так как на время работы влияет не размер делителя p, а гладкость p-1.

Размер B зависит, в основном, от времени, которое мы можем потратить. Кроме того, на него влияет существование второй стадии алгоритма. Обычные значения B - где-то от 105 до 106.
p-1 метод, стадия 2.      А теперь - существенное улучшения P-1 алгоритма. Требование существования простого делителя N, такого что p - 1 - гладкое степени B, - слишком строгое. Более рационально положить условие полной разложимости p - 1 при простом делении до B. То есть сделаем возможным существование одного простого делителя, большего B. Но это значит, что p - 1 = f * q, где f - B-гладкое, а q - простое число, возможно, гораздо большее B ( но не B2 ). Для наших целей мы несколько усилим условие и предположим, что у N есть простой делитель р, такой что p - 1 \ f * q, где f - гладкое степени B1 , и q - такое простое, что B1 < q <= B2, где B1 - cтарое B и B2 - гораздо большая константа.

Покажем, как мы будем искать такое p. Очевидно, p - 1 - гладкое степени B2, таким образом мы могли бы использовать стадию 1 с B1 замененным на В2, однако, это нереально, так как B2 - гораздо большая константа, чем В1.

Тем же путем получаем

НОД ( аq*НОК(1..В) - 1 , N ) > 1

и поступаем так: в конце первой стадии у нас будет вычислено b := aНОК(1..В) mod N. Мы храним таблицу разностей простых от B1 до B2. Теперь эти разности малы и у нас их немного. Таким образом мы можем легко вычислить bd для всех возможных разностий d и получить все bd, умножая начальную степень b на эти заранее вычисленные bd. Следовательно, для каждого простого, мы заменяем возведение в степень простым умножением, которое гораздо быстрее, и поэтому мы можем пойти много дальше.

Теорема Ферма — Эйлера (другие названия — рождественская теорема Ферма, теорема о представлении простых чисел в виде суммы двух квадратов) гласит:

Любое простое число p=4n+1, где n — натуральное число, представимо в виде суммы квадратов двух натуральных чисел.

В иностранной литературе это утверждение часто называют рождественской теоремой Ферма, так как она стала известна из письма Пьера Ферма, посланного 25 декабря 1640 года.

Примеры: 
5=1^{2}+2^{2}
13=2^{2}+3^{2}

# Выполнение лабораторной работы

1. Реализовал алгоритм p-метода Полларда (рис. [-@fig:001]).

![Код и вывод](image/1.png){#fig:001 width=70%}

2. Реализовал метод квадратов (Теорема Ферма о разложении) (рис. [-@fig:002]).

![Код и вывод](image/2.png){#fig:002 width=70%}

# Выводы

Успешно удалось получить понимание как раскладывать числа на множители. Реализовал на практике алгоритм p-метода Полларда и метод квадратов (Теорема Ферма о разложении).

# Список литературы{.unnumbered}

::: {#refs}
:::
